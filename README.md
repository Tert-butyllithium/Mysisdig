# My sysdig

> The *goal* of this project is to create another `sysdig` ~~(although impossible)~~

[Sysdig](https://github.com/draios/sysdig) is an awesome tool for capturing syscalls; however, it is too complex and not very suitable for `arm` devices (especially for developing board without package manager)

In our test (the same evluation environment as **Performance Evaluation**), the overall overhead could reach up to **15%**!!!

`My sysdig` aims to provide limited features to minimize dependencies and overhead

> WARNING: Mysysdig is a developing project and all functions have not been fully tested.

## User Manual 

Basically, you can `make` to compile the driver and then `insmod my_sysdig.ko` to install the kernel module. 

Then you could open file `/etc/syscall-record/record` to find all syscall logs. (You might need to create the directory and delete the file before run)

```bash
pid=22569, unknown, res=1
pid=22569, accept4, res=15
pid=22569, epoll_ctl, res=0
pid=22569, epoll_wait, res=1
pid=22569, accept4, res=16
pid=22569, epoll_ctl, res=0
pid=22569, epoll_wait, res=1
pid=22569, accept4, res=17
pid=22569, epoll_ctl, res=0
pid=22569, epoll_wait, res=1
pid=22569, accept4, res=18
pid=22569, epoll_ctl, res=0
```

### Filter condition

- `pid`: `insmod my_sysdig.ko pid=1234`
- `proc_name`: `insmod my_sysdig.ko proc_name=test_syscall`

Note: because of the constraint of Linux, we will only compare the first 15 characters of `proc_name`

## Handlers for different type of syscalls

handler function are defined in the end of `syscalls/handlers.h`. To regitser it to let `Mysysdig` know, relavant codes are defined in `syscalls/handlers-table.h`

For example `read_handle` to handle the syscall `read` 

```c
int read_handle(char* small_buf, struct pt_regs* regs, unsigned long syscall_no,
                long ret, unsigned long arg0) {
  int fd = arg0;
  void* buf = (void*)get_arg1(regs);
  size_t count = get_arg2(regs);
  // NOTE: need ARGS_BUF_SIZE + 1 to save '\0'
  char buf_tmp[ARGS_BUF_SIZE + 1];
  assemble_buf_arg(buf_tmp, buf, ret);
  sprintf(small_buf, "pid=%d, read, fd=%d, size=%ld, res=%ld, data%s=%s\n",
          current->pid, fd, count, ret, (ret > ARGS_BUF_SIZE ? "(part)" : ""),
          buf_tmp);
  return 0;
}
```

There are two tables in `handlers-table.h` are corresponded to register these handlers. The table also shows all types of syscalls are special treated.

```c
typedef int (*handler_callback)(char*, struct pt_regs*, unsigned long, long,
                                unsigned long);
handler_callback functions[] = {
    &getuid_handle, &recvfrom_handle, &socket_handle, &fstat_handle,
    &getcwd_handle, &lseek_handle,    &futex_handle,  &sendto_handle,
    &clone_handle,  &read_handle,     &mmap_handle,   &exit_group_handle,
    &close_handle,  &tgkill_handle,   &munmap_handle, &nanosleep_handle,
    &ppoll_handle,  &dup_handle,      &ioctl_handle};

char handler_string[][32] = {
    "getuid", "recvfrom",  "socket", "fstat", "getcwd",     "lseek", "futex",
    "sendto", "clone",     "read",   "mmap",  "exit_group", "close", "tgkill",
    "munmap", "nanosleep", "ppoll",  "dup",   "ioctl"};
```


## Performance Evaluation

tl;dr: the overhead is extremely low (~1%)

### Test settings: 
- nginx web server (with a complex html page), 
- Juno r2 board, with 2 * Cortex-A72 and 4 * Cortex-A53 
- test by ` ab -n 500000 -c 100 http://localhost/`, 50 times

### Test result

|             | **baseline** | **Default**      |
| ----------- | ------------ | ---------------- |
| **1**       | 144.139      | 137.249          |
| **2**       | 133.001      | 135.170          |
| ...      | ...     | ...         |
| **46**      | 139.766      | 142.664          |
| **47**      | 141.629      | 144.294          |
| **48**      | 132.655      | 139.153          |
| **49**      | 141.153      | 156.555          |
| **50**      | 138.816      | 140.288          |
| **avg**     | 139.21458    | 140.5195         |
| **ratio** |              | 1.00937344349996 |

### What's the cost?

A process could issue many times of syscalls with a second, so the trace file can be very large..

The size of the recod file generated by this test is 2.16G (almost 1G/h)


## TO-DO List

- [x] record parameter changes for different types of syscall
- [ ] ~~capture interrupt...~~
- [x] using buffer instead of outputing to `dmesg`
- [x] make more test